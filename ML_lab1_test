import numpy as np
import os
import time
import math
import sys
import datetime
import matplotlib
matplotlib.use("Agg")  # 避免无显示环境下阻塞
import matplotlib.pyplot as plt
import xml.etree.ElementTree as ET

from simulation_and_control import pb, MotorCommands, PinWrapper, feedback_lin_ctrl, SinusoidalReference

# =========================
# Utils
# =========================

def makedirs(path):
    os.makedirs(path, exist_ok=True)
    return path

def now_tag():
    return datetime.datetime.now().strftime("%Y%m%d-%H%M%S")

def compute_metrics(y_true, y_pred, p):
    """
    返回: dict(rss, tss, r2, r2_adj, F, dof_num, dof_den)
    p: 自变量维度 (参数个数)
    """
    y_true = np.asarray(y_true).ravel()
    y_pred = np.asarray(y_pred).ravel()
    rss = float(np.sum((y_true - y_pred) ** 2))
    tss = float(np.sum((y_true - np.mean(y_true)) ** 2))
    n = len(y_true)
    r2 = 1.0 - rss / (tss + 1e-12)
    dof_num = max(p, 1)
    dof_den = max(n - p, 1)
    # 经典线性回归 F 统计量（用于整体显著性检验）
    F = ((tss - rss) / dof_num) / (rss / dof_den + 1e-12)
    # Adjusted R^2
    r2_adj = 1.0 - (1.0 - r2) * (n - 1) / max(n - p - 1, 1)
    return dict(rss=rss, tss=tss, r2=r2, r2_adj=r2_adj, F=F, dof_num=dof_num, dof_den=dof_den)

def ci_from_ols(X, y, a_hat, ridge_lambda=0.0, alpha=0.05):
    """
    基于 (X^T X + λI)^(-1) 估计协方差并给出 (1-alpha) 置信区间（正态近似）。
    """
    X = np.asarray(X)
    y = np.asarray(y).ravel()
    n, p = X.shape
    lamI = ridge_lambda * np.eye(p)
    XtX = X.T @ X + lamI
    # 残差方差
    resid = y - X @ a_hat
    dof = max(n - p, 1)
    sigma2 = float(resid @ resid) / dof
    cov = sigma2 * np.linalg.inv(XtX)
    stderr = np.sqrt(np.clip(np.diag(cov), 0.0, np.inf))
    # 1.96对应95%置信区间（大样本正态近似）
    z = 1.96 if abs(alpha - 0.05) < 1e-12 else 1.96
    lo = a_hat - z * stderr
    hi = a_hat + z * stderr
    return lo, hi, stderr, sigma2

def parse_urdf_link7_true_params(urdf_path, link_name_candidates=("panda_link7", "link7")):
    """
    尝试从 URDF 解析 link7 的真实参数，返回 a7_true: [m, mcx, mcy, mcz, Ixx, Ixy, Ixz, Iyy, Iyz, Izz]
    - 若 inertial.origin 有位姿，会把惯量张量从 inertia frame 旋转到 link frame（近似处理）。
    - 如果无法解析，返回 None。
    """
    if not os.path.isfile(urdf_path):
        return None
    try:
        tree = ET.parse(urdf_path)
        root = tree.getroot()
        ns = ""  # 有些URDF无命名空间
        def find_link(root, names):
            for link in root.findall(f"{ns}link"):
                nm = link.get("name", "")
                for cand in names:
                    if cand in nm:
                        return link
            return None

        link = find_link(root, link_name_candidates)
        if link is None:
            return None
        inertial = link.find(f"{ns}inertial")
        if inertial is None:
            return None

        mass_tag = inertial.find(f"{ns}mass")
        inertia_tag = inertial.find(f"{ns}inertia")
        origin_tag = inertial.find(f"{ns}origin")

        m = float(mass_tag.get("value"))
        # CoM 在 origin 的 xyz
        com_xyz = np.array([0.0, 0.0, 0.0])
        R = np.eye(3)
        if origin_tag is not None:
            if origin_tag.get("xyz"):
                com_xyz = np.array(list(map(float, origin_tag.get("xyz").split())))
            if origin_tag.get("rpy"):
                rpy = list(map(float, origin_tag.get("rpy").split()))
                roll, pitch, yaw = rpy
                cr, sr = math.cos(roll), math.sin(roll)
                cp, sp = math.cos(pitch), math.sin(pitch)
                cy, sy = math.cos(yaw), math.sin(yaw)
                Rz = np.array([[cy, -sy, 0],[sy, cy, 0],[0,0,1]])
                Ry = np.array([[cp, 0, sp],[0,1,0],[-sp, 0, cp]])
                Rx = np.array([[1,0,0],[0,cr,-sr],[0,sr,cr]])
                R = Rz @ Ry @ Rx

        Ixx = float(inertia_tag.get("ixx"))
        Ixy = float(inertia_tag.get("ixy"))
        Ixz = float(inertia_tag.get("ixz"))
        Iyy = float(inertia_tag.get("iyy"))
        Iyz = float(inertia_tag.get("iyz"))
        Izz = float(inertia_tag.get("izz"))
        I_in_inertia = np.array([[Ixx, Ixy, Ixz],
                                 [Ixy, Iyy, Iyz],
                                 [Ixz, Iyz, Izz]])
        # 旋转到 link frame（近似：忽略并未提供的 link 固定位姿差异）
        I_link = R @ I_in_inertia @ R.T

        a7_true = np.array([
            m, m*com_xyz[0], m*com_xyz[1], m*com_xyz[2],
            I_link[0,0], I_link[0,1], I_link[0,2], I_link[1,1], I_link[1,2], I_link[2,2]
        ])
        return a7_true
    except Exception:
        return None

# =========================
# Simulation + Identification
# =========================

def run_sim(conf_file_name, cur_dir, amplitude, frequency, duration=10.0, kp=1000.0, kd=100.0, seed=42, phase=None):
    """
    单次仿真，返回:
      Y_blocks: (T, n, 10n)  regressor
      U_blocks: (T, n)       measured torques
    """
    rng = np.random.default_rng(seed)

    sim = pb.SimInterface(conf_file_name, conf_file_path_ext=cur_dir)
    ext_names = sim.getNameActiveJoints()
    ext_names = np.expand_dims(np.array(ext_names), axis=0)
    source_names = ["pybullet"]
    dyn_model = PinWrapper(conf_file_name, "pybullet", ext_names, source_names, False, 0, cur_dir)
    n = dyn_model.getNumberofActuatedJoints()

    # 轨迹参考：若 SinusoidalReference 支持相位，用它；否则我们在 get_values 后手动加相位。
    amplitude = np.asarray(amplitude).reshape(n)
    frequency = np.asarray(frequency).reshape(n)
    if phase is None:
        phase = rng.uniform(0, 2*np.pi, size=n)
    phase = np.asarray(phase).reshape(n)

    ref = None
    try:
        # 有的实现已有相位参数，可尝试
        ref = SinusoidalReference(amplitude, frequency, sim.GetInitMotorAngles(), phase=phase)
        use_phase_in_class = True
    except TypeError:
        # 回退：类不支持相位，我们之后手动加
        ref = SinusoidalReference(amplitude, frequency, sim.GetInitMotorAngles())
        use_phase_in_class = False

    time_step = sim.GetTimeStep()
    current_time = 0.0
    max_time = float(duration)

    cmd = MotorCommands()
    regressor_all = []
    tau_mes_all = []

    frames = 0
    start = time.time()

    while current_time < max_time:
        q_mes = sim.GetMotorAngles(0)
        qd_mes = sim.GetMotorVelocities(0)
        qdd_mes = sim.ComputeMotorAccelerationTMinusOne(0)

        q_d, qd_d = ref.get_values(current_time)
        if not use_phase_in_class:
            # 若类不支持相位： q_d(t) += A*sin(2π f t + φ) - A*sin(2π f t) 的差额（近似修正）
            # 但为了不破坏类内部实现，我们简单地在目标位置上叠加一个相位偏移项
            q_d = q_d + amplitude * (np.sin(2*np.pi*frequency*current_time + phase) - np.sin(2*np.pi*frequency*current_time))

        tau_cmd = feedback_lin_ctrl(dyn_model, q_mes, qd_mes, q_d, qd_d, kp, kd)
        cmd.SetControlCmd(tau_cmd, ["torque"] * n)
        sim.Step(cmd, "torque")

        tau_mes = sim.GetMotorTorques(0)

        try:
            regressor = dyn_model.ComputeDynamicRegressor(q_mes, qd_mes, qdd_mes)  # (n, 10n)
        except Exception as e:
            raise RuntimeError(f"ComputeDynamicRegressor failed at t={current_time:.4f}: {e}")

        regressor_all.append(np.array(regressor))
        tau_mes_all.append(np.array(tau_mes).reshape(-1))

        frames += 1
        if frames % 200 == 0:
            print(f"[run_sim] t={current_time:.2f}s, frames={frames}")

        # 禁用键盘事件以免PDF换行导致静默
        # keys = sim.GetPyBulletClient().getKeyboardEvents()
        # qKey = ord('q')
        # if qKey in keys and keys[qKey] and sim.GetPyBulletClient().KEY_WAS_TRIGGERED:
        #     break

        current_time += time_step

    dt = time.time() - start
    print(f"[run_sim] finished: frames={frames}, duration={dt:.2f}s, avg_hz={frames/max(dt,1e-6):.1f}")

    Y_blocks = np.stack(regressor_all, axis=0)  # (T, n, 10n)
    U_blocks = np.stack(tau_mes_all, axis=0)    # (T, n)
    return Y_blocks, U_blocks, n

def stack_last_joint(Y_blocks, U_blocks):
    """
    取每个时间步“最后一个关节”的一行回归与扭矩：
    返回 X: (T, 10), y: (T,)
    """
    T, n, ten_n = Y_blocks.shape
    assert ten_n == 10*n, f"regressor width unexpected: {ten_n} vs 10*{n}"
    X_list, y_list = [], []
    for t in range(T):
        Y_t = Y_blocks[t]         # (n, 10n)
        U_t = U_blocks[t]         # (n,)
        X_list.append(Y_t[-1, -10:])  # last joint, last 10 params
        y_list.append(U_t[-1])
    X = np.vstack(X_list)
    y = np.array(y_list)
    return X, y

def estimate_a7(X, y, ridge_lambda=1e-8):
    """
    求解 a7_hat （10维），返回 (a7_hat, info)
    """
    p = X.shape[1]
    lamI = ridge_lambda * np.eye(p)
    XtX = X.T @ X + lamI
    a7_hat = np.linalg.solve(XtX, X.T @ y)
    cond = np.linalg.cond(XtX)
    rank = np.linalg.matrix_rank(X)
    info = dict(cond=cond, rank=rank)
    return a7_hat, info

def plot_fit(y, y_pred, out_path, title):
    plt.figure()
    plt.plot(y, label="measured τ7")
    plt.plot(y_pred, label="predicted τ7")
    plt.xlabel("time step")
    plt.ylabel("torque (Nm)")
    plt.legend()
    plt.title(title)
    plt.tight_layout()
    plt.savefig(out_path, dpi=150)
    plt.close()

# =========================
# Main pipeline (Dual-run)
# =========================

def main():
    """
    双仿真流程：
      Run A：估计 link7 的 10 个参数 a7_hat
      Run B：使用 A 的 a7_hat 在新数据上做预测与评估（严格符合“重复仿真再评估”的要求）
    并计算：R²、Adjusted R²、F-stat、95%CI；保存CSV与图
    """
    cur_dir = os.path.dirname(os.path.abspath(__file__))
    conf_file_name = "pandaconfig.json"

    out_dir = makedirs(os.path.join(cur_dir, f"lab1_out_{now_tag()}"))

    # --- 轨迹设计：A/B 两次仿真使用不同频率与相位，提升可辨识性且满足“重复仿真评估” ---
    # 建议频率互不相等、避免共振；幅值适中
    amp = np.array([np.pi/4, np.pi/6, np.pi/5, np.pi/5, np.pi/6, np.pi/5, np.pi/6])
    freq_A = np.array([0.37, 0.53, 0.61, 0.43, 0.71, 0.47, 0.59])
    freq_B = np.array([0.41, 0.57, 0.63, 0.45, 0.73, 0.49, 0.55])  # 与A不同
    duration = 12.0
    kp, kd = 1000.0, 100.0

    print("\n=== Run A: estimation ===")
    Y_A, U_A, n = run_sim(conf_file_name, cur_dir, amp, freq_A, duration=duration, kp=kp, kd=kd, seed=123)
    X_A, y_A = stack_last_joint(Y_A, U_A)   # link7 的 (T,10) 与 (T,)
    print(f"[A] X_A: {X_A.shape}, y_A: {y_A.shape}")

    a7_hat, infoA = estimate_a7(X_A, y_A, ridge_lambda=1e-8)
    yA_pred = X_A @ a7_hat
    metA = compute_metrics(y_A, yA_pred, p=X_A.shape[1])
    ciA_lo, ciA_hi, stderrA, sigma2A = ci_from_ols(X_A, y_A, a7_hat, ridge_lambda=1e-8)

    print("\n[A] link7 parameters (10):")
    print("a7_hat:", a7_hat)
    print(f"[A] R^2={metA['r2']:.4f}, R^2_adj={metA['r2_adj']:.4f}, F={metA['F']:.2f}  (df={metA['dof_num']},{metA['dof_den']})")
    print(f"[A] cond(X^T X)≈{infoA['cond']:.2e}, rank(X)={infoA['rank']}")
    print("[A] 95% CI low :", ciA_lo)
    print("[A] 95% CI high:", ciA_hi)
    plot_fit(y_A, yA_pred, os.path.join(out_dir, "A_tau7_fit.png"), "Run A (train) τ7 fit")

    # --- 可选：从 URDF 读取“真值”对比（若失败则跳过） ---
    urdf_path = os.path.join(cur_dir, "models", "panda_description", "panda.urdf")
    a7_true = parse_urdf_link7_true_params(urdf_path, link_name_candidates=("panda_link7","link7"))
    if a7_true is not None:
        param_err = a7_hat - a7_true
        print("\n[A] compare to URDF link7 (approx packed as [m,mcx,mcy,mcz,Ixx,Ixy,Ixz,Iyy,Iyz,Izz])")
        print("a7_true:", a7_true)
        print("a7_hat - a7_true:", param_err)
        np.savetxt(os.path.join(out_dir, "A_a7_true.csv"), a7_true, delimiter=",")
        np.savetxt(os.path.join(out_dir, "A_a7_param_error.csv"), param_err, delimiter=",")

    # 保存 A 结果
    np.savetxt(os.path.join(out_dir, "A_X.csv"), X_A, delimiter=",")
    np.savetxt(os.path.join(out_dir, "A_y.csv"), y_A, delimiter=",")
    np.savetxt(os.path.join(out_dir, "A_a7_hat.csv"), a7_hat, delimiter=",")
    np.savetxt(os.path.join(out_dir, "A_a7_ci_low.csv"), ciA_lo, delimiter=",")
    np.savetxt(os.path.join(out_dir, "A_a7_ci_high.csv"), ciA_hi, delimiter=",")
    with open(os.path.join(out_dir, "A_metrics.txt"), "w") as f:
        f.write(f"R2={metA['r2']:.6f}\nR2_adj={metA['r2_adj']:.6f}\nF={metA['F']:.6f}\n")
        f.write(f"dof=({metA['dof_num']},{metA['dof_den']})\n")
        f.write(f"cond={infoA['cond']:.6e}\nrank={infoA['rank']}\n")

    print("\n=== Run B: validation on new trajectory ===")
    Y_B, U_B, _ = run_sim(conf_file_name, cur_dir, amp, freq_B, duration=duration, kp=kp, kd=kd, seed=999)
    X_B, y_B = stack_last_joint(Y_B, U_B)
    print(f"[B] X_B: {X_B.shape}, y_B: {y_B.shape}")

    yB_pred = X_B @ a7_hat
    metB = compute_metrics(y_B, yB_pred, p=X_B.shape[1])
    ciB_lo, ciB_hi, stderrB, sigma2B = ci_from_ols(X_B, y_B, a7_hat, ridge_lambda=1e-8)

    print("\n[B] validation metrics (using a7_hat from A):")
    print(f"[B] R^2={metB['r2']:.4f}, R^2_adj={metB['r2_adj']:.4f}, F={metB['F']:.2f}  (df={metB['dof_num']},{metB['dof_den']})")
    print("[B] 95% CI (based on B residuals):")
    print(" low :", ciB_lo)
    print(" high:", ciB_hi)
    plot_fit(y_B, yB_pred, os.path.join(out_dir, "B_tau7_fit.png"), "Run B (val) τ7 fit")

    # 保存 B 结果
    np.savetxt(os.path.join(out_dir, "B_X.csv"), X_B, delimiter=",")
    np.savetxt(os.path.join(out_dir, "B_y.csv"), y_B, delimiter=",")
    np.savetxt(os.path.join(out_dir, "B_y_pred.csv"), yB_pred, delimiter=",")
    np.savetxt(os.path.join(out_dir, "B_a7_ci_low.csv"), ciB_lo, delimiter=",")
    np.savetxt(os.path.join(out_dir, "B_a7_ci_high.csv"), ciB_hi, delimiter=",")
    with open(os.path.join(out_dir, "B_metrics.txt"), "w") as f:
        f.write(f"R2={metB['r2']:.6f}\nR2_adj={metB['r2_adj']:.6f}\nF={metB['F']:.6f}\n")
        f.write(f"dof=({metB['dof_num']},{metB['dof_den']})\n")

    print(f"\n[OK] outputs saved to: {out_dir}")
    print("  - A_tau7_fit.png / B_tau7_fit.png 图")
    print("  - A/B_X.csv, A/B_y.csv, A_a7_hat.csv, A/B_metrics.txt 等")
    print("  - 若解析到 URDF 真值，则有 A_a7_true.csv 与 A_a7_param_error.csv (近似)")

if __name__ == '__main__':
    main()
